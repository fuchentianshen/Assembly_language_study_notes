### 1.“转移”综述

一般情况下指令是顺序地逐条执行的，而在实际中，常需要改变程序的执行流程。

- 转移指令

  可以控制CPU执行内存中某处代码的指令

  可以修改IP或同时修改CS和IP的指令

- 转移指令的分类

  ![image-20230826170034194](https://cdn.jsdelivr.net/gh/fuchentianshen/Typora_cloudimg/img/image-20230826170034194.png)

  ![image-20230826170107372](https://cdn.jsdelivr.net/gh/fuchentianshen/Typora_cloudimg/img/image-20230826170107372.png)

  ![image-20230826170130627](https://cdn.jsdelivr.net/gh/fuchentianshen/Typora_cloudimg/img/image-20230826170130627.png)

### 2.操作符offset

> 用操作符offset取得标号的偏移地址

格式：

```assembly
offset 标号
```

### 3.jmp指令——无条件转移

- jmp指令的功能
  - 无条件转移，可以只修改IP，也可以同时修改CS和IP

- jmp指令要给出两种信息：

  - 转移的目的地址

  - 转移的距离

    段间转移( 远转移) ：jmp far ptr

    段内短转移： jmp short 标号；IP的修改范围为-128~127，8位的位移

    段内近转移:：jmp near ptr 标号；IP的修改范围为 -32768~32767，16位的位移

jmp short 的机器指令中，包含的是跳转到指令的相对位置而不是转移的目标地址。

jmp near part指明了相对于当前IP的转移位移，而不是转移的目的地址。

jmp far ptr指明了跳转到的目的地址，即包含了标号的段地址CS和偏移地址IP。

- 转移地址在寄存器中的jmp指令

  指令格式：jmp 16位寄存器

  功能：IP=(16位寄存器 )

- 转移地址在内存中的jmp指令

  - 段内转移：jmp word ptr 内存单元地址

    功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址

  - 段间转移：jmp dword ptr 内存单元地址

    功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。

**jmp指令小结**

![image-20230827125811326](https://cdn.jsdelivr.net/gh/fuchentianshen/Typora_cloudimg/img/image-20230827125811326.png)

### 4.其他转移指令

- **jcxz指令**（jmp cx zero）

  指令格式：jcxz 标号

  功能:

  ​	如果(cx)=0，则转移到标号处执行

  ​	当(cx)!=0时，什么也不做( 程序向下执行 )

  - 当(cx)=0时，(IP)=(IP)+8位位移

    8位位移=“标号”处的地址-jcxz指令后的第一个字节的地址

    8位位移的范围为-128~127，用补码表示

    8位位移由编译程序在编译时算出

    ![image-20230827133225253](https://cdn.jsdelivr.net/gh/fuchentianshen/Typora_cloudimg/img/image-20230827133225253.png)

  jcxz是有条件转移指令

  - 所有的有条件转移指令都是短转移
  - 对IP的修改范围都为-128~127
  - 在对应的机器码中包含转移的位移而不是目的地址

- **loop指令**

  指令格式：loop 标号

  指令操作

  1. (cx)=(cx)-1；

  2. 当(cx)!=0时，则转移到标号处执行

     当(cx)=0时，程序向下执行

  - 如果(cx)！=0，IP=IP+8位位移

    8位位移=“标号”处的地址-loop指令后的第一个字节的地址

    8位位移的范围为-128~127，用补码表示

    8位位移由编译程序在编译时算出

  ![image-20230827133940400](https://cdn.jsdelivr.net/gh/fuchentianshen/Typora_cloudimg/img/image-20230827133940400.png)

> 根据位移进行“相对”转移的意义
>
> （在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移。）
>
> - 如果 loop s 的机器码中包含的是 s 的地址，则就对程序段在内存中的偏移地址有了严格的限制，易引发错误
> - 当机器码中包含的是转移的位移，无论 s 处的指令的实际地址是多少，loop指令转移的相对位移是不变的。
>
> 这样的设计，方便了程序段在内存中的浮动装配。

### 5.call指令和ret指令

模块化程序设计：

调用子程序:call指令
返回 :ret指令



**call指令**

- 实质:流程转移
  call指令实现转移的方法和jmp指令的原理相似

- CPU执行call指令，进行两步操作:

  (1)将当前的IP或CS和IP 压入栈中;

  (2)转移到标号处执行指令

- call 标号

  16位位移“标号”处的地址 - call指令后的第一个字节的地址

  16位位移的范围为-32768~32767，用补码表示

  16位位移由编译程序在编译时算出

**指令“call far ptr 标号”实现的是段间转移**

- CPU执行“call far ptr 标号”时的操作

  1. (sp)=(sp)-2

     ((ss) x16+(sp))=(CS)

     (sp)=(sp)-2

     ((ss) x16+(sp))=(IP)

  2. (CS)= 标号所在的段地址

     (lP)=标号所在的偏移地址

- “call far ptr 标号”相当于

  push CS

  push IP

  jmp far ptr 标号

|        | ret指令 | retf指令 |
| :----- | ------- | -------- |
| 功能   | 用栈中的数据，修改IP的内容，从而实现近转移 | 用栈中的数据，修改CS和IP的内容，从而实现远转移 |
| 相当于 | pop IP  | pop IP   popCS |

### 6.call 和 ret 的配合使用

模块化编程

### 7.mul 指令——乘法

格式
mul 寄存器

mul 内存单元

![image-20230827164804158](https://cdn.jsdelivr.net/gh/fuchentianshen/Typora_cloudimg/img/image-20230827164804158.png)

### 8.汇编语言的模块化程序设计

> 调用子程序:call 指令
>
> 返回:ret指令
> 子程序:根据提供的参数处理一定的事务，处理后，将结果(返回值)提供给调用者

### 9.寄存器冲突的问题

两个可能方案

1. 在写调用子程序的程序时，注意看看子程序中有没有用到会产生冲突的寄存器

   如果有，调用者使用别的寄存器;

2. 在编写子程序的时候，不要使用会产生冲突的寄存器。

我们希望

1. 编写调用了程序的程序的时候不必关心子程序到底使用了哪些寄存器
2. 编写子程序的时候不必关心调用者使用了哪些寄存器
3. 不会发生寄存器冲突

> 子程序标准框架
>
> 子程序开始 : 子程序中使用的寄存器入栈
>
> 子程序内容
>
> 子程序使用的寄存器出栈
>
> 返回 ( ret、retf )



> 可行的解决方案：
>
> 在子程序的开始将要用到的所寄存器中的内容都保存起来，在子程序返回前再恢复

### 10.标志寄存器

- 标志寄存器的结构

  flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息

  8086CPU中没有使用flag的1、3、5、12、13、14、15位，这些位不具有任何含义。

  ![image-20230828151420172](https://cdn.jsdelivr.net/gh/fuchentianshen/Typora_cloudimg/img/image-20230828151420172.png)

- 标志寄存器的作用

  用来存储相关指令的某些执行结果

  用来为CPU执行相关指令提供行为依据

  用来控制CPU的相关工作方式

  ![image-20230828151602810](https://cdn.jsdelivr.net/gh/fuchentianshen/Typora_cloudimg/img/image-20230828151602810.png)
  
- ZF-零标志

  ZF标记相关指令的计算结果是否为0

  ZF=1，表示“结果是0”，1表示“逻辑真”

  ZF=0，表示“结果不是0”，0表示“逻辑假”

- PF-奇偶标志(Parity Flag)

  PF记录指令执行后，结果的所有二进制位中1的个数

  1的个数为偶数，PF=1

  1的个数为奇数，PF=0

- SF-符号标志(Sign Flag)

  SF记录指令执行后，将结果视为有符号数

  结果为负，SF=1

  结果为非负，SF = 0

  ![image-20230828154714462](https://cdn.jsdelivr.net/gh/fuchentianshen/Typora_cloudimg/img/image-20230828154714462.png)

- CF-进位标志(Carry Flag)

  在进行无符号数运算的时候，CF记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值

  CF记录指令执行后：

  有进位或借位，CF=1

  无进位或借位，CF=0

- OF-溢出标志(Overflow Flag)

  在进行有符号数运算的时候，如结果超过了机器所能表示的范围称为溢出

  OF记录有符号数操作指令执行后，

  有溢出，OF= 1

  无溢出，OF=0

  注意，此处益出只是对有符号数运算而言。

> CF和OF的区别
> CF是对**无符号数**运算有意义的进/借位标志位
>
> OF是对**有符号数**运算有意义的溢出标志位

### 11.带进(借)位的加减法

**adc-带进位加法指令**

adc是带进位加法指令，它利用了CF位记录的进位值

格式:adc 操作对象1 操作对象2

功能:操作对象1=操作对象1+操作对象2+CF

**sbb-带借位减法指令**
格式:sbb 操作对象1操作对象2

功能:操作对象1=操作对象1-操作对象2-CF

与sub区别:利用CF位上记录的借位值

### 12.cmp和条件转移指令

cmp指令

格式:cmp 操作对象1 操作对象2

功能:计算操作对象1-操作对象2

条件转移指令

```assembly
cmp oper1,oper2 ;或者其他影响标志寄存器的指令
jxxx 标号
```

![image-20230829153753793](C:/Users/%E6%AD%A6%E5%90%AB/AppData/Roaming/Typora/typora-user-images/image-20230829153753793.png)

![image-20230829155647490](C:/Users/%E6%AD%A6%E5%90%AB/AppData/Roaming/Typora/typora-user-images/image-20230829155647490.png)

jxxx系列指令和cmp指令配合实现高级语言中if语句的功能

### 13.条件转移指令应用

通过检测标志位，由标志位体现条件

条件转移指令通常都和cmp相配合使用，cmp指令改变标志位

### 14.DF标志和串传送指令 

**DF-方向标志位( Direction Flag)**

- 功能

  在串处理指令中，控制每次操作后si，di的增减。

  DF=0:每次操作后si，di递增;

  DF=1:每次操作后si，di递减

- 对DF位进行设置的指令

  cld指令:将标志寄存器的DF位设为0(clear)

  std指令:将标志寄存器的DF位设为1(setup)

**串传送指令**

1. movsb
   功能 :( 以字节为单位传送 )

   1. ((es)x16 + (di)) = ((ds) x 16 + (si))

   2. 如果DF = 0 则:

      (si) = (si) + 1
      (di) = (di) + 1

      如果DF = 1则 : 

      (si) = (si) - 1

      (di) = (di) - 1

2. movsw

   功能 : ( 以字为单位传送 )

   1. ((es)x16 + (di)) = ((ds) x 16 + (si))

   2. 如果DF = 0则 :

       (si) = (si) + 2

      (di) = (di) + 2

      如果DF = 1

      则 : (si) = (si) - 2

      (di) = (di) - 2

**rep指令**

rep指令常和串传送指令搭配使用

功能：根据cx的值，重复执行后面的指令